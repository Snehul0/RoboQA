import sys
import os
import numpy as np

# --- CRITICAL FIX: Ensure ROS 2 Jazzy libraries are found ---
# This line is necessary if the environment cannot automatically find rosbag2_py
sys.path.append('/opt/ros/jazzy/lib/python3.12/site-packages')

try:
    from rosbag2_py import SequentialReader, StorageOptions, ConverterOptions
except ImportError as e:
    print(f"ERROR: Could not import rosbag2_py. {e}")
    print("Please ensure you have run: source /opt/ros/jazzy/setup.bash")
    sys.exit(1)

def get_timestamps(bag_path, topics):
    """
    Extract timestamps for specific topics from a ROS 2 Bag file.
    Returns: Dictionary {topic_name: [timestamp1, timestamp2, ...]}
    """
    print(f"Reading Bag: {bag_path} ...")
    reader = SequentialReader()
    
    # Set storage options (ROS 2 Jazzy uses mcap by default)
    storage_options = StorageOptions(uri=bag_path, storage_id='mcap')
    converter_options = ConverterOptions('', '')
    
    try:
        reader.open(storage_options, converter_options)
    except Exception as e:
        print(f"Failed to open Bag: {e}")
        return None

    timestamps = {t: [] for t in topics}
    count = 0

    while reader.has_next():
        topic, msg, t_ns = reader.read_next()
        if topic in topics:
            # Convert nanoseconds to seconds (float)
            t_sec = t_ns / 1e9
            timestamps[topic].append(t_sec)
            count += 1
            
    print(f"Reading complete. Found {count} relevant messages.")
    return timestamps

def calculate_sync_metrics(timestamps_map, topic_a, topic_b):
    """
    Calculate synchronization metrics between two topics.
    Topic A is the Reference, Topic B is the Target (to be measured).
    Algorithm: For each timestamp in A, find the closest timestamp in B and calculate the difference.
    """
    ts_a = np.sort(timestamps_map[topic_a])
    ts_b = np.sort(timestamps_map[topic_b])

    if len(ts_a) == 0 or len(ts_b) == 0:
        print(f"WARNING: Data for {topic_a} or {topic_b} is empty. Cannot analyze.")
        return None, None

    offsets = []
    
    # Use searchsorted for efficient nearest neighbor lookup
    idxs = np.searchsorted(ts_b, ts_a)
    
    for i, idx in enumerate(idxs):
        candidates = []
        # Check the neighbor to the right
        if idx < len(ts_b):
            candidates.append(abs(ts_a[i] - ts_b[idx]))
        # Check the neighbor to the left
        if idx > 0:
            candidates.append(abs(ts_a[i] - ts_b[idx-1]))
            
        if candidates:
            # Use the minimum time difference as the synchronization error for this frame
            offsets.append(min(candidates))

    offsets = np.array(offsets)
    
    # --- Calculate Statistical Metrics ---
    metrics = {
        'mean_offset_ms': np.mean(offsets) * 1000, # Milliseconds
        'std_dev_ms': np.std(offsets) * 1000,      # Milliseconds (Jitter)
        'max_offset_ms': np.max(offsets) * 1000,
        'count': len(offsets)
    }
    
    return metrics, offsets

def main():
    # --- 1. Configuration ---
    # Note: This points to the file generated by convert_kitti_to_bag.py
    # Please verify your username is correct (xtai)
    bag_file = "/home/xtai/RoboQA/kitti_test_bag/kitti_test_bag_0.mcap"
    
    target_topics = ["/camera/image_raw", "/lidar/points"]

    # --- 2. Check if file exists ---
    if not os.path.exists(bag_file):
        print(f"ERROR: File not found: {bag_file}")
        print("Please check the path, or ensure convert_kitti_to_bag.py ran successfully.")
        return

    # --- 3. Extract Data ---
    data = get_timestamps(bag_file, target_topics)
    if not data:
        return

    # --- 4. Analyze and Print Report ---
    print("\n" + "="*50)
    print("   RoboQA - Feature 1 Report: Multi-Sensor Sync")
    print("="*50)
    
    cam = target_topics[0]
    lidar = target_topics[1]
    
    if not data[cam] or not data[lidar]:
        print("ERROR: Missing sensor data. Cannot calculate synchronization.")
        return

    metrics, _ = calculate_sync_metrics(data, cam, lidar)
    
    if metrics:
        print(f"Reference Sensor: {cam}")
        print(f"Target Sensor:    {lidar}")
        print("-" * 50)
        print(f"Total Messages: {metrics['count']}")
        print(f"Mean Offset:    {metrics['mean_offset_ms']:.4f} ms")
        print(f"Sync Jitter:    {metrics['std_dev_ms']:.4f} ms")
        print(f"Max Offset:     {metrics['max_offset_ms']:.4f} ms")
        print("-" * 50)
        
        # --- Simple Pass/Fail Check ---
        # Autonomous driving typically requires sync error < 10ms (example threshold)
        threshold = 20.0
        if metrics['mean_offset_ms'] < threshold:
            print("✅ RESULT: PASS (Good Synchronization)")
        else:
            print(f"❌ RESULT: FAIL (Offset > {threshold}ms)")
    print("="*50 + "\n")

if __name__ == "__main__":
    main()